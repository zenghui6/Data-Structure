# Data-Structure
### 线性结构

- [x] 动态数组
- [x] 栈 (方法栈,括号匹配)
- [x] 队列
- 普通队列
- 循环队列
- [x] 链表

**栈和队列**可以使用**动态数组**实现,也可以使用**链表**实现

动态数组底层是静态数组,只是多了size (元素数量,并指向尾部) 实现了扩容和缩容

### 非线性结构
- [x] 树
- 二分搜索树
- 平衡二叉树
- [ ] 堆
- [X] 集合和映射
  
**集合**和**映射**基于可**二分搜索树**实现,也可使用**链表**实现  
java中的**TreeSet基于TreeMap实现**
**TreeMap**基于红黑树


#### 二分搜索树:
- 二分搜索树是一个二叉树
- 存储的元素必须有可比性
- 二分搜索树的每个节点的值:
    - 大于其左子树的所有节点的值
    - 小于其右子树的所有节点的值

##### 二分搜索树删除指定元素的方法:

 1. 删除只有左孩子的节点,返回右节点
 2. 删除只有右孩子的节点,返回左节点
 3. 删除叶子节点与删除只有左孩子的节点是一样的,相当于只有做孩子且左孩子为空,返会左孩子就行
 4. 删除左右都有孩子的节点: 找它的前驱(左子树的最大值)或后继(右子树的最小值)


#### 映射:Map<K,V>
使用链表和二叉搜索树可以构建Map,只需要在Node中加入值V value,
当然链表要去重
Node节点信息:

        public K key;
        public V value;
        public Node next;


#### 递归算法的写法:
1. 写出最终递归终止的判断条件
2. 继续深入递归 并 给定返回的地方
3. 递归回来的时候执行的操作,处理

### 树的应用
#### 优先队列
优先队列是动态的,随时根据新元素的入队来调整队列

优先队列的底层为堆: 入队: O(log n) 出队: O(log n);
> 一般出现时间复杂度为logn的 基本都与树有关

#### 堆
##### 二叉堆: 
1. 二叉堆是一个完全二叉树(一层一层,从左往右,不能上层还有空,下层有节点)
2. 堆中的某个节点的值总是不大于其父节点的值(最大堆,相对应也有最小堆)

**实现方法:**
1. 使用数组存储二叉堆:
    - parent(i) = i-1/2
     - left child(i) = 2*i + 1
     - right child(i) = 2*i+ 2
     
##### 优先队列:
使用堆实现优先队列

#### 线段树
如果区间有n 个元素,数组表示需要多少个节点?
**需要4n的空间** (估计值)我们的线段树不考虑添加元素,即区间固定使用4n的静态空间即可

#### 前缀树 (字典树)
节点信息:
```java
private class Node{
        public boolean isWord;  //这个节点是否是单词尾
        public TreeMap<Character,Node> next; //下一个节点map
}
```
root 节点不存储字符

#### 平衡二叉树
> 平衡因子 : 左右子树的高度差

左右节点的高度叉不大于1

#### AVL树
即是一颗二叉搜索树,也是一颗平衡二叉树
##### AVL树在什么时候维持平衡?
加入节点后,向上回溯维持平衡性





